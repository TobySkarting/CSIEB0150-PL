#include <stdio.h>
#include <stdlib.h>

FILE *in_fp;
char nextChar;
int charClass;
int lexLen;
char lexeme[100];
int nextToken;

/* Character Classes */
#define LETTER   0
#define DIGIT    1
#define REAL_DOT 2
#define UNKNOWN  99

/* Token Codes */
#define INT_LIT     10
#define IDENT       11
#define REAL_LIT    12
#define ASSIGN_OP   20
#define ADD_OP      21
#define SUB_OP      22
#define MUL_OP      23
#define DIV_OP      24
#define LEFT_PAREN  25
#define RIGHT_PAREN 26


void getChar()
{
	if ((nextChar = fgetc(in_fp)) != EOF)
		if (isdigit(nextChar))
			charClass = DIGIT;
		else if (isalpha(nextChar))
			charClass = LETTER;
		else if (nextChar == '.')
			charClass = REAL_DOT;
		else
			charClass = UNKNOWN;
	else
		charClass = EOF;
}

void getNonBlank()
{
	while (isspace(nextChar))
		getChar();
}

/* addChar - a function to add nextChar to lexeme */
void addChar()
{
	if (lexLen <= 98)
	{
		lexeme[lexLen++] = nextChar;
		lexeme[lexLen] = 0;
	}
	else
		printf("ERROR - lexeme is too long.\n");
}

/* lookup - a function to lookup operators and parentheses and return the token. */
int lookup(char c)
{
	addChar();
	switch (c)
	{
	case '(':
		nextToken = LEFT_PAREN;
		break;
	case ')':
		nextToken = RIGHT_PAREN;
		break;
	case '=':
		nextToken = ASSIGN_OP;
		break;
	case '+':
		nextToken = ADD_OP;
		break;
	case '-':
		nextToken = SUB_OP;
		break;
	case '*':
		nextToken = MUL_OP;
		break;
	case '/':
		nextToken = DIV_OP;
		break;
	default:
		nextToken = EOF;
		break;
	}
	return nextToken;
}


/* lex - lexical analyzer */
void lex()
{
	lexLen = 0;
	getNonBlank();

	switch (charClass)
	{
	case LETTER:
		addChar();
		getChar();
		while (charClass == DIGIT || charClass == LETTER)
		{
			addChar();
			getChar();
		}
		nextToken = IDENT;
		break;
	case DIGIT:
		addChar();
		getChar();
		if (charClass == REAL_DOT)
		{
			addChar();
			getChar();
			while (charClass == DIGIT)
			{
				addChar();
				getChar();
			}
			nextToken = REAL_LIT;
		}
		else
		{
			while (charClass == DIGIT)
			{
				addChar();
				getChar();
			}
			nextToken = INT_LIT;
		}
		break;
	default:
	case UNKNOWN:
		lookup(nextChar);
		getChar();
		break;
	case EOF:
		strcpy(lexeme, "EOF");
		nextToken = EOF;
		break;
	}

	printf("Next token is %d. Next lexeme is %s\n", nextToken, lexeme);
}

void expr();
void term();
void factor();
void error();

/* expr - parses string in the language generated by the rule 
	<expr> -> <term> { ( + | - ) <term> } */
void expr()
{
	printf("Enter <expr>\n");
	term();
	while (nextToken == ADD_OP || nextToken == SUB_OP)
	{
		lex();
		term();
	}
	printf("Exit <expr>\n");
}

/* term - parses string in the language generated by the rule
	<term> -> <factor> { ( * | / ) <factor> } */
void term()
{
	printf("Enter <term>\n");
	factor();
	while (nextToken == MUL_OP || nextToken == DIV_OP)
	{
		lex();
		factor();
	}
	printf("Exit <term>\n");
}

/* factor - parses string in the language generated by the rule
	<factor> -> <id> | <int_constant> | (expr) */
void factor()
{
	printf("Enter <factor>\n");
	if (nextToken == IDENT || nextToken == INT_LIT)
		lex();
	else if (nextToken == LEFT_PAREN)
	{
		lex();
		expr();
		if (nextToken == RIGHT_PAREN)
			lex();
		else
			error();
	}
	else
		error();
	printf("Exit <factor>\n");
}

void error()
{
	printf("An error occurred while parsing the string.\n");
	exit(-1);
}

int main()
{
	if ((in_fp = fopen("sub.txt", "r")) == NULL)
		printf("ERROR - cannot open front.txt.\n");
	else
	{
		getChar();
		do
		{
			lex();
			expr();
		} while (nextToken != EOF);
	}
	return 0;
}
